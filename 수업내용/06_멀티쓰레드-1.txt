게임서버에서 가장 중요한 것
- 안정성
	. 멀티쓰레드를 하면 안정성이 떨어진다.
	. 멀티쓰레드를 잘 해서 안정성을 유지하자
- 성능
	. 성능을 높이려면?
	  프로그램 최적화
	  멀티코어 활용
	. 멀티코어를 활용하려면?
	  멀티쓰레드 프로그래밍이 필요

멀티쓰레드
- 하나의 프로그램의 여러 곳이 동시다발적으로 실행되는
  프로그래밍 기법
- 최근 가장 많이 사용되는 병렬처리 프로그래밍 기법

병렬처리
- 하나의 작업을 여러 개의 콘텍스트에서 동시 수행하는 것
	. 콘텍스트: CPU의 실행 상태=>PC를 포함한 모든 레지스터의 값
	. 여러 대의 컴퓨터를 사용하는 경우
	  분산시스템, 클러스터
	  SETI
	. 한 대의 컴퓨터를 사용하는 경우
	  SMP : 여러 개의 CPU (Symmetric Multi Processing)
	  Multi-Core : 여러 개의 Core

왜 병렬처리를 하는가
- 한 개의 CPU의 처리속도가 너무 느리기 때문

왜 병렬처리가 각광받는가
- 발열의 한계에 부딪친 클럭 속도
- 제작사의 사활을 건 멀티코어 CPU의 보급
- 콘솔, 모바일 기기의 멀티 core화

프로세스와 쓰레드
- 프로세스: 실행 중인 프로그램
- 쓰레드: 프로그램 실행의 흐름
	. 프로세스 실행 중 프로그램이 쓰레드 생성 명령 실행

	. 프로그램은 하나의 프로세스가 되어서 실행된다.
	. 처음에는 하나의 쓰레드로 실행
	. 쓰레드는 다른 쓰레드를 만들 수 있다. -> 멀티쓰레드의 시작
	. 각각의 쓰레드는 자신의 스택을 가지고 있고
	  같은 프로세스의 모든 쓰레드는 data와 code, heap을 공유한다.
	  쓰레드가 늘어나면 스택의 개수도 증가한다.

멀티쓰레드
	. 콘텍스트가 여러 개 있다.
단일 쓰레드 프로그램은 PCB(Process Control Block)을 하나 가지고 있다.
멀티 쓰레드 프로그램은 PCB 내에 TCB(Thread Control Block)을 여러 개 가지고 있다.

멀티쓰레드에서의 메모리 접근
- 메모리
- 전역변수(data): 모든 쓰레드가 공유한다.
- 지역변수(stack): 쓰레드마다 따로따로 존재한다.
- 지역변수도 강제로 공유할 수 있다.
	. 지역변수의 주소를 전역변수에 저장하면 된다.
	. 그러지 말자

멀티쓰레드에서의 자연 공유
- 모든 자원(메모리, 파일 핸들, 윈도우 핸들 등)은 공유된다.

장점
- 성능 향상
- 빠른 응답 속도
- 더 나은 자원 활용(CPU Core)
- 멀티프로세스 프로그램보다 효율적
	. 통신
	  프로세스끼리 데이터를 주고받는것 보다 쓰레드끼리 주고받는 것이 훨씬 빠르다.
	. context switch
	  프로세스끼리 context switch보다 쓰레드끼리 context switch가 훨씬
	  오버헤드가 적다.
위험
- 프로그램 복잡도 증가
- 디버깅의 어려움 (data race, deadlock)


두 종류의 프로그래밍 스타일
- Heterogeneous
	. 작업을 역할 별로 나누어서 전용 쓰레드에게 맡기는 스타일
	. bottlenect thread가 있을 수 있다.
- Homogenous (event driven, data driven)
	. 작업을 쪼개서 쓰레드 구분 없이 나누어 하는 스타일
게임 서버는 Homogenous
	. 패킷 하나를 한 조각의 작업으로 생각
	. 동접 5000이면 최대 5000개의 조각
게임 클라이언트는 Heterogeneous
	. 렌더링 쓰레드, 물리 엔진 쓰레드, 장면 구성 쓰레드

주의점
- 쓰레드의 개수가 많다고 좋은 것이 아니다.
- 프로세서/코어의 개수에 맞추어라
	. 코어보다 많은 쓰레드 -> 컨텍스트 스위치 부하. 반응속도 저하
- 너무 많은 쓰레드 => 운영체제 및 하드웨어에 부담

- 내가 사용하는 메모리의 내용이 내가 아닌 다른
  쓰레드에 의해서 변경된 수 있음을 유념해야 한다.
	. DATA RACE라고 부름
	. Single Core 컴퓨터도 마찬가지

Windows에서의 멀티쓰레드 프로그래밍
- Windows에서는 멀티쓰레드를 기본 지원
	. Kernel Level Thread
	. 사실상 멀티쓰레드에 특화된 OS
	. 추가 헤더, 라이브러리 파일 필요 없음.
	. 쓰레드를 멀티코어에 잘 분배
- 쓰레드 문맥 전환(Context Switch)
	. Windows의 스케줄러가 알아서 함
	  - x86 CPU에 쓰레드 전환 명령어 존재
	. 프로그램에서 OS에 요청할 수도 있음
- Windows 고유의 API가 존재하나 C++11의 표준을 따르는 방식 권장

더하는 코드에서 lock을 쓰지 않으면 틀린 결과가 나오는 이유
- Data Race 때문
Data Race란
- 같은 메모리를 한 개 이상의 쓰레드가 동시에 읽고 쓰는 경우
- 그 중 적어도 한 개는 반드시 쓰기일 것

lock, unlock
- mutex 객체는 전역 변수로
- 같은 객체 사이에서만 lock/unlock이 동작한다.
	. 다른 mutex 객체는 상대방을 모른다.
- mutex 함수가 아니라 mutex 객체가 필요한 이유
	. 서로 동시에 실행돼도 괜찮은 Critical Section이 있으면
  	  서로 다른 mutex 객체로 보호하는 것이 성능이 좋다.
	. 같은 mutex 객체로 보호하면 동시에 실행이 안 됨

lock 사용 시 주의점
- lock의 부하
	. lock 호출 자체가 상당한 부하를 유발한다.
	. 호출한 코어 뿐만 아니라 다른 코어와 다른 CPU에도 delay를 발생시킨다.
- lock의 크기 (임계영역의 크기)
	. 너무 작다: lock이 자주 호출되어 성능 저하가 심해진다.
	. 너무 크다: lock을 얻지 못해 오랫동안 대기하는 쓰레드로 인한
	  성능 감소가 커진다. 병렬성이 떨어진다.

Thread 여러 개로 성능 향상
- 올바른 결과가 나와야 함
- Single Thread 프로그램보다 빨라야 함.
- 멀티쓰레드 프로그램은 싱글코어에서 싱글쓰레드 프로그램보다 느릴 수 있음
- 방법 : Lock의 개수를 최소화 하고, 병렬 수행을 최대화 해야 함
  => 알고리즘 수정(재작성)

정리
- 게임서버의 성능 향상을 위해서는 멀티쓰레드 프로그래밍이 필수이다.
- 멀티코어 환경에서는 메모리 공유에 주의해야 한다. (Data Race)
- lock은 성능저하를 초래한다.
- lock을 최소한도로 사용하도록 프로그램을 재작성해야 한다.

배열을 만들어서 따로 더한 후 메인에서 합산하면?
- 느리다
- Line 단위의 캐시 핑퐁 현상 (False Sharing)

int 읽었다고 해서 cpu가 메모리에서 4바이트만 읽어가는 것이 아니다.
cpu에 cache가 있고, 메모리를 읽을 땐 캐시 라인 단위로 읽는다.
intel cpu의 캐시라인은 64바이트다. 4바이트만 필요해도 64바이트를 다 읽는다.
sum 배열의 sum[2]를 업데이트 해야 한다고 할 때,
sum[0], [1], [3]..등과 같은 라인에 있는게 문제가 된다.
똑같은 주소의 메모리가 각 코어의 캐시 두 군데에 존재하면 안 된다.
코어가 sum0을 업데이트 한 값을 코어1에서도 읽어야 한다.
전역변수를 업데이트하면 업데이트 한 값이 보여야 하는데,
캐시라인을 둘 다 갖고 있으면 서로 자기 것만 업데이터 하고,
상대 코어에 보이지 않으면 데이터 영역을 공유하는 것이 의미가 없어진다.
그래서 인텔에서 cpu 만들 때, 같은 캐시라인을 두개의 코어가 공유할 수 없도록 했다.
read only라면 상관 없지만, write가 하나라도 들어가면 절대 공유할 수 없다.
그래서 sum0에 있는 데이터를 업데이트 시키는 순간, 코어1에 있는 캐시 라인을
무효화 시켜야 한다.
그래서 서로 무효화 되는 현상이 일어나며 캐시라인이 핑퐁된다.
이것을 cache thrashing이라고 하는데, 이걸 하면서 성능 저하가 일어난다.

alignas(64) volatile int sums[MAX_THREADS]
- 숫자 만큼 메모리를 차지하도록 변수를 선언한다.
- int가 64바이트 단위로 떨어진다.

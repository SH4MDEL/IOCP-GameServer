Test의 필요성
- bug 없는 프로그램을 만들기 위해

MMORPG 게임 고유의 Test
- 부하 테스트 (stress test)
- 성능 측정 (동접, hotspot)

Stress Test
- 많은 인원이 동시에 접속하여 Test
- 적은 인원 Test시에는 보이지 않았던 Bug들을 발견할 수 있다.
	. 특히 멀티쓰레드 버그
- 서버 프로그램의 Bottle Nect을 발견할 수 있다.
	. DB - 쿼리 최적화, 캐시서버두기, nospl로 바꾸기, 하드디스크를 ssd로 바꾸기 등등..
	. Network Overhead - 패킷 크기가 큰지, 패킷을 자주 보내는지 등
	. Memory Allocation Overhead - 메모리 많이 꼽기 등
	. NPC AI Overhead - 최적화, ai를 별도의 서버로 돌리기 등

CPU Bottle Nect -> 프로파일러로 어디서 CPU를 많이 사용했나 확인한다.
Network Bottle Nect -> 버퍼에 데이터가 쌓이는 것을 확인한다.
Database Bottle Nect -> 데이터베이스 Request 큐가 얼마나 쌓여있나 확인한다.

Test의 단계
- 작성자 테스트, QA 테스트
- 알파 테스트
	. 비 관계자를 동원한 테스트
	. 같은 회사의 다른 팀원, 개발자의 가족/친구
- 클로즈드 베타 테스트
	. 불특정 다수 동원, 실제 부하 테스트의 시작
	. 모집광고 -> 인원선정 -> 클라이언트 배포 -> 테스트
- 오픈 베타 테스트
	. 모든 사람에게 공개해서 테스트
	. 오픈 베타 테스트 중 이상이 없으면 그대로 상용화

Stress Test의 문제
- 많은 인원의 동원이 쉽지 않다.
	. 잦은 클베?
	. 동접 5000 서버의 테스트?
- 원하는 시간의 테스트가 힘들다
- 통제가 힘들다
	. 원하는 시나리오
- 해결책
	. 자동 테스트 프로그램

자동 테스트 프로그램
- Dummy Client라고도 불림
- No Visual
- 하나의 프로그램에서 여러 개의 캐릭터로 동시 접속
	. 테스트 비용 감소 (PC 대수 감소, 동시 실행 클라이언트 수 감소)
	. 보통 수백 개의 접속
	. ID를 미리 만들어 놓아야 함
- 내부 AI를 이용한 테스트
	. 이동
	. 전투

- PC 여러 대를 사용해 테스트
	. 500 접속 Dummy Client * 10대 PC => 5000동접
한계
- 복잡한 작업을 수행하기 힘들다.
- 실제 인간의 행동과 차이가 날 수밖에 없다.

고려 사항
- 캐릭터 생성도 자동으로 하게 해 놓으면 편하다.
- 지형을 입력해서 빈번한 잘못된 이동을 하지 않도록 하는 것이 좋다.
- 테스트 캐릭터의 공간적 분포를 고려해야한다.
	. Teleport를 통한 분산을 위해 관리자 레벨의 ID 발급 필요
- 서버 프로그램의 업그레이드 시 같이 업드레이드 해주어야 한다.
	. 아니면 필요할 때 쓰기가 힘들어진다.

자동 테스트 프로그램의 구조
- IOCP를 사용한 다중 접속
- FSM을 사용한 접속 및 Test
	. Login id 별로 state가 있고, 서버에서 오는 packet의
	  종류에 따라 state가 변화하면서 action을 취한다.
- 대부분의 서버 packet 무시
	. status 변경, 다른 캐릭터 이동
- 간단한 graphic으로 화면상에 전체 test character들의 분포와
  state를 볼 수 있게 한다.

서버의 성능은 어떻게 아는가?
- 부하를 주고 서버가 견디는가 확인
- 부하 : 동접 또는 HotSpot
- 견디는가? : 랙이 있는가?
랙 측정?
- 사람이 측정 -> 부정확
- 클라이언트에서 보낸 신호가 서버에 갔다가
  되돌아 올 때까지의 시간을 측정
	. 거꾸로 하면 클라이언트의 랙 측정

랙 측정
- 별도의 랙 측정 패킷을 정의해서 주고 받을 수 있음
	. 최소 랙이 측정됨
- 가장 많이 사용되는 패킷을 통해 측정
	. Move Packet에 전송 시간을 추가해서 측정
	. Move Packet에 time stamp를 추가해야 함.


//// MIDTERM ////


테스트 결과
- CPU 사용량 100% => CPU가 bottle nect

Profilling
- SW를 실행하고 어느 부분에서 CPU를 많이 사용하는지 계측하는 작업
	. 여러 가지 방법이 있다.
- 보통은 Kernel에서 주기적으로 CPU의 PC레지스터값을 읽어서
  어떤 코드를 실행하고 있는지 기록
	. 프로그램에 함수들의 주소가 있으므로 이를 통해 어떤 함수를
	  실행 중인지 판단할 수 있다.
	. 이를 통해 어떤 함수가 CPU를 많이 사용하는지 알 수 있다.
- 지금은 CPU에 프로파일링 기능이 내장되어 있다.


결과
- do_move() 함수에서 대부분의 시간을 소비 => bottle nect
	. WSASend에서 CPU 소비
	  - 우리가 작성한 함수가 아니므로 최적화 불가능
	  - 호출 횟수를 줄여야 한다.
	. mutex lock(), mutex unlock()
	  - 멀티 쓰레드 프로그램에서는 lock()이 문제
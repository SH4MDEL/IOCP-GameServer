1. 패킷을 자주 보내야 되는데, 서버와 네트워크의 오버헤드가 크다.

2. 클라이언트 변조를 통한 해킹에 취약해진다.

3. CPU 사이의 캐시 동기화 구현 여부

4. 네트워크 하부 레이어에서 패킷 전송을 그때의 상황에 맞춰서 하기때문에

5. Busy Waiting (패킷을 전송하지 않는 클라이언트에 대한 Recv로 인한 CPU 낭비)

6. 
A - 비동기식 I/O
B - 완료 후에 재사용해야 함
C - 파라미터를 통해 결정
D - 그냥 쓰면 안되고 쓰기 전에 초기화해야 함
E - O
F - Non Overlapped로 처리해도 된다.
G - 완료 후에 재사용해야 한다.

7. Callback 함수를 호출

8. 운영체제가 쓰레드를 실제 물리코어에 할당한다.

9.
상호 배제 : 자원 사용을 하나의 쓰레드에서만 하게 해서 충돌을 막는 행위
임계 영역 : lock으로 보호받는 프로그램 영역
경쟁 상태 : 여러 개의 쓰레드가 동시에 공유메모리에 접근해서 
		실행순서에 따라 실행 결과가 달라지는 현상

10.
A - 꼭 그렇게 하지 않아도 된다.
B - IOCP에서는 Callback 함수를 사용하지 않는다.
C - 할 수 있지만 권장하지 않는다.
D - 그렇게 하지 않아도 멀티쓰레드에서 동작한다.
E - O
F - 소켓은 연결만 하고 만들지는 않는다.
G - 완료가 되면 재사용 할 수 있다.

11.
hIOCP : 서버에서 생성한 IOCP 객체를 지정한다.
dwIOSize : 완료된 I/O에서 보내거나 받은 데이터의 크기이다.
key : 소켓을 구분하기 위해 프로그램에 지정한 고유 id
lp : Send/Recv에서 사용한 Overlapped 구조체의 주소
INFINITE : GQCS 함수의 최대 대기시간

12.
A - O
B - 오히려 오류가 줄어들 가능성이 있다.
C - O
D - O
E - 발생하지 않는다.
F - 적합하지 않다.

13
p[0]
ex_over->_send_buf, p, remain_data

14
sizeof(_recv_over._over) - _prev_remain
ex_over->send_buf + _prev_remain

15
while (remain_data > 1)
	int packet_size = p[0] + [1] * 256;

16.
A - 오히려 더 많이 발생
B - 맞지만 틀림
C - O
D - mutex를 사용하면 atomic하게 동작한다.
E - O
F - O
G - O (HW로 구현하지 않으면 구현할 수 없다)
H - 느려질 수 있다.

17. 적은 PC로 원하는 동접을 테스트하도록 만든다. Visual을 삭제하고, 
	하나의 클라이언트에서 여러 유저를 시뮬레이션 하며,
	고성능 I/O 모델을 사용해서 동시 테스트 유저의 수를 늘린다.